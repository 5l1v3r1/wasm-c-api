diff --git a/src/wasm/wasm-objects-inl.h b/src/wasm/wasm-objects-inl.h
index e1fc2d2410..ec3f04be57 100644
--- a/src/wasm/wasm-objects-inl.h
+++ b/src/wasm/wasm-objects-inl.h
@@ -125,6 +125,7 @@ SMI_ACCESSORS(WasmTableObject, raw_type, kRawTypeOffset)
 // WasmMemoryObject
 ACCESSORS(WasmMemoryObject, array_buffer, JSArrayBuffer, kArrayBufferOffset)
 SMI_ACCESSORS(WasmMemoryObject, maximum_pages, kMaximumPagesOffset)
+ACCESSORS(WasmMemoryObject, host_owned, Object, kHostOwnedOffset)
 OPTIONAL_ACCESSORS(WasmMemoryObject, instances, WeakArrayList, kInstancesOffset)
 
 // WasmGlobalObject
diff --git a/src/wasm/wasm-objects.cc b/src/wasm/wasm-objects.cc
index 27a56695c2..55d205b534 100644
--- a/src/wasm/wasm-objects.cc
+++ b/src/wasm/wasm-objects.cc
@@ -1223,9 +1223,23 @@ void SetInstanceMemory(Handle<WasmInstanceObject> instance,
 
 }  // namespace
 
+WasmMemoryObject::HostOwnedStoreInfo::~HostOwnedStoreInfo() {
+  DCHECK(memory);
+  auto buffer = memory->array_buffer();
+  DCHECK(buffer.IsJSArrayBuffer());
+  void* store = buffer.backing_store();
+
+/*TODO
+  Isolate* isolate = buffer.GetIsolate();
+  HandleScope(isolate) handle_scope;
+  wasm::DetachMemoryBuffer(isolate, Handle<JSArrayBuffer>(buffer), false);
+*/
+  if (free_callback) free_callback(store, callback_info);
+}
+
 Handle<WasmMemoryObject> WasmMemoryObject::New(
     Isolate* isolate, MaybeHandle<JSArrayBuffer> maybe_buffer,
-    uint32_t maximum) {
+    uint32_t maximum, std::unique_ptr<HostOwnedStoreInfo> host_owned) {
   Handle<JSArrayBuffer> buffer;
   if (!maybe_buffer.ToHandle(&buffer)) {
     // If no buffer was provided, create a 0-length one.
@@ -1243,6 +1257,20 @@ Handle<WasmMemoryObject> WasmMemoryObject::New(
       isolate->factory()->NewJSObject(memory_ctor, AllocationType::kOld));
   memory_obj->set_array_buffer(*buffer);
   memory_obj->set_maximum_pages(maximum);
+  if (host_owned) {
+    DCHECK(host_owned->memory.is_null());
+    host_owned->memory =
+        isolate->global_handles()->Create<WasmMemoryObject>(*memory_obj);
+/*TODO
+    GlobalHandles::MakeWeak(
+        reinterpret_cast<Address**>(host_owned->memory.address()));
+*/
+    auto managed = Managed<HostOwnedStoreInfo>::FromUniquePtr(
+        isolate, sizeof(HostOwnedStoreInfo), std::move(host_owned));
+    memory_obj->set_host_owned(*managed);
+  } else {
+    memory_obj->set_host_owned(ReadOnlyRoots(isolate).undefined_value());
+  }
 
   return memory_obj;
 }
@@ -1308,10 +1336,16 @@ int32_t WasmMemoryObject::Grow(Isolate* isolate,
                                Handle<WasmMemoryObject> memory_object,
                                uint32_t pages) {
   TRACE_EVENT0(TRACE_DISABLED_BY_DEFAULT("v8.wasm"), "GrowMemory");
+  HostOwnedStoreInfo* host_owned = nullptr;
+  if (!memory_object->IsUndefined()) {
+    host_owned =
+        Managed<HostOwnedStoreInfo>::cast(memory_object->host_owned())->raw();
+  }
   Handle<JSArrayBuffer> old_buffer(memory_object->array_buffer(), isolate);
   if (old_buffer->is_shared() && !FLAG_wasm_grow_shared_memory) return -1;
   auto* memory_tracker = isolate->wasm_engine()->memory_tracker();
-  if (!memory_tracker->IsWasmMemoryGrowable(old_buffer)) return -1;
+  if (!(host_owned || memory_tracker->IsWasmMemoryGrowable(old_buffer)))
+      return -1;
 
   // Checks for maximum memory size, compute new size.
   uint32_t maximum_pages = wasm::max_mem_pages();
@@ -1335,7 +1369,19 @@ int32_t WasmMemoryObject::Grow(Isolate* isolate,
   // Handle this in the interrupt handler so that it's safe for all the isolates
   // that share this buffer to be updated safely.
   Handle<JSArrayBuffer> new_buffer;
-  if (old_buffer->is_shared()) {
+  if (host_owned) {
+    // TODO: handle shared host-owned memory once we support it.
+    auto new_store = host_owned->grow_callback(
+        old_buffer->backing_store(), host_owned->callback_info,
+        old_size, new_size);
+    if (!new_store) return -1;
+    bool is_external = old_buffer->is_external();
+    DCHECK(is_external);
+    // Disconnect buffer early so GC won't free it.
+    wasm::DetachMemoryBuffer(isolate, old_buffer, false);
+    new_buffer =
+        wasm::SetupArrayBuffer(isolate, new_store, new_size, is_external);
+  } else if (old_buffer->is_shared()) {
     // Adjust protections for the buffer.
     if (!AdjustBufferPermissions(isolate, old_buffer, new_size)) {
       return -1;
diff --git a/src/wasm/wasm-objects.h b/src/wasm/wasm-objects.h
index 1e6ced0b76..434514f947 100644
--- a/src/wasm/wasm-objects.h
+++ b/src/wasm/wasm-objects.h
@@ -327,10 +327,20 @@ class V8_EXPORT_PRIVATE WasmTableObject : public JSObject {
 // Representation of a WebAssembly.Memory JavaScript-level object.
 class WasmMemoryObject : public JSObject {
  public:
+  struct HostOwnedStoreInfo {
+    auto (*grow_callback)(void*, void*, size_t, size_t) -> void* = nullptr;
+    void (*free_callback)(void*, void*) = nullptr;
+    void* callback_info = nullptr;
+    Handle<WasmMemoryObject> memory = Handle<WasmMemoryObject>();
+
+    ~HostOwnedStoreInfo();
+  };
+
   DECL_CAST(WasmMemoryObject)
 
   DECL_ACCESSORS(array_buffer, JSArrayBuffer)
   DECL_INT_ACCESSORS(maximum_pages)
+  DECL_ACCESSORS(host_owned, Object)
   DECL_OPTIONAL_ACCESSORS(instances, WeakArrayList)
 
   // Dispatched behavior.
@@ -347,7 +357,8 @@ class WasmMemoryObject : public JSObject {
   inline bool has_maximum_pages();
 
   V8_EXPORT_PRIVATE static Handle<WasmMemoryObject> New(
-      Isolate* isolate, MaybeHandle<JSArrayBuffer> buffer, uint32_t maximum);
+      Isolate* isolate, MaybeHandle<JSArrayBuffer> buffer, uint32_t maximum,
+      std::unique_ptr<HostOwnedStoreInfo> host_owned = nullptr);
 
   V8_EXPORT_PRIVATE static MaybeHandle<WasmMemoryObject> New(
       Isolate* isolate, uint32_t initial, uint32_t maximum,
